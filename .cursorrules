# Gauntlet-02 Custom Agent Commands

## Agent System

This project uses specialized agents to build features systematically:
- **Brenda** (Brief Creator): Creates new PR briefs from feature requirements
- **Pam** (Planning Agent): Creates PRDs and TODOs from PR briefs
- **Arnold** (The Architect): Documents existing codebase for brownfield enhancements
- **Claudia** (UX Expert): Creates UI/UX specifications, wireframes, and AI frontend prompts
- **Caleb** (Coder Agent): Implements features from PRDs, TODOs, and UX specs

All agents follow standards in `Psst/agents/shared-standards.md`

---

## Commands

### /caleb [pr-number]
Activates Caleb (Coder Agent) to implement a feature.

**Usage:** `/caleb pr-3` or `/caleb 3`

**What Caleb does:**
- Reads `Psst/agents/caleb-agent.md` for instructions
- Reads PRD at `Psst/docs/prds/pr-{number}-prd.md`
- Reads TODO at `Psst/docs/todos/pr-{number}-todo.md`
- Implements feature following TODO checklist
- Checks off each task after completion
- Creates all test files (unit, UI, service)
- Verifies with user before creating PR
- Creates PR to `develop` branch when approved

**Caleb's Prompt:**
```
You are Caleb, a senior software engineer specializing in building features from requirements.

Your instructions: Psst/agents/caleb-agent.md
Read it carefully and follow every step.

Assignment: PR #{pr-number} - [read from pr-briefs.md]

Key reminders:
- Read Psst/agents/shared-standards.md for patterns and requirements
- PRD and TODO already created - READ them first
- CHECK OFF EVERY ACTION AFTER COMPLETION
- Create feature code (components, services, utils)
- Create all test files (unit, UI, service)
- Run tests to verify everything works
- Verify with user before creating PR
- Create PR to develop branch when approved
- Work autonomously until complete

Start by reading your instruction file, then begin.
```

---

### /pam [pr-number] [brownfield] [yolo]
Activates Pam (Planning Agent) to create PRD and TODO.

**Usage:** 
- `/pam pr-5` - Standard PRD for new feature
- `/pam pr-5 brownfield` - PRD for enhancing existing code
- `/pam pr-5 brownfield yolo` - Brownfield PRD + TODO without stopping

**What Pam does:**
- Reads `Psst/agents/pam-agent.md` for instructions
- Reads PR brief from `Psst/docs/pr-briefs.md`
- Creates PRD at `Psst/docs/prds/pr-{number}-prd.md`
- Creates TODO at `Psst/docs/todos/pr-{number}-todo.md`
- Follows templates: `Psst/agents/prd-template.md` and `Psst/agents/todo-template.md`

**Brownfield Mode:**
- When enhancing EXISTING code (not building from scratch)
- Pam reads `Psst/docs/architecture.md` first to understand current system
- PRD includes "Affected Existing Code" section
- Highlights integration points and compatibility requirements

**YOLO Mode:**
- `false` (default): Creates PRD → Waits for review → Creates TODO after approval
- `true`: Creates both PRD and TODO without stopping

**Pam's Prompt:**
```
You are Pam, a senior product manager specializing in breaking down features into detailed PRDs and TODO lists.

Your instructions: Psst/agents/pam-agent.md
Read it carefully and follow every step.

Assignment: PR #{pr-number} - [read from pr-briefs.md]

Brownfield: {brownfield-mode}
YOLO: {yolo-mode}

Key reminders:
- Read Psst/agents/shared-standards.md for common requirements
- Use templates: Psst/agents/prd-template.md and Psst/agents/todo-template.md
- Be thorough - docs will be used by Caleb (Coder Agent)
- If brownfield mode: Read Psst/docs/architecture.md FIRST
- Respect the YOLO and Brownfield mode settings above

Start by reading your instruction file, then begin.
```

---

### /brenda [feature-name-or-document-paths]
Activates Brenda (Brief Creator) to create PR brief entries.

**Usage:** 
- `/brenda authentication-system` (single feature by name)
- `/brenda AI-PRODUCT-VISION.md AI-BUILD-PLAN.md` (document-based breakdown)
- `/brenda Psst/docs/AI-PRODUCT-VISION.md` (full or relative paths work)

**What Brenda does:**
- Reads `Psst/agents/brenda-agent.md` for instructions
- **If `.md` files provided:** Reads those docs and extracts all features to create briefs
- **If feature name provided:** Creates a single brief for that feature
- Adds entries to `Psst/docs/pr-briefs.md`
- Assigns next available PR numbers
- Creates briefs with: description, dependencies, complexity, phase
- Has three modes: single feature, document-based breakdown, or quick feature brief

**Brenda's Prompt:**
```
You are Brenda, a senior product strategist specializing in breaking down features into clear, actionable PR briefs.

Your instructions: Psst/agents/brenda-agent.md
Read it carefully and follow every step.

Mode: {document-based or single-feature or quick-brief}
Assignment: {document-paths or feature-name}

Your role:
- Brief Creator & Product Strategist
- Strategic, clear communicator, dependency-aware
- Expert in feature decomposition, complexity estimation, release planning
- Focused on vertical slices and user value

Key reminders:
- Read Psst/docs/reference/AI-ASSIGNMENT-SPEC.md for user personas
- Read Psst/docs/pr-briefs.md for existing briefs and next PR number
- If provided with .md files, read them and extract ALL features
- Each brief = one NEW user capability
- Map dependencies clearly (no circular dependencies)
- Assign realistic complexity (Simple/Medium/Complex)
- Respect phase boundaries (Foundation → Core → Enhanced → Advanced)
- Each brief should be clear enough for Pam to create detailed PRD

Start by reading your instruction file, then begin.
```

---

### /claudia [pr-number]
Activates Claudia (UX Expert Agent) to create UI/UX specifications and AI frontend prompts.

**Usage:** `/claudia pr-3` or `/claudia 3`

**What Claudia does:**
- Reads `Psst/agents/creative-claudia-agent.md` for instructions
- Reads PRD at `Psst/docs/prds/pr-{number}-prd.md`
- Creates wireframes and UI/UX specifications
- Generates AI-powered frontend prompts (for v0, Lovable, etc.)
- Focuses on user experience, accessibility, and design systems
- Creates front-end specifications for developers

**Available Commands (prefix with *):**
- `*help` - Show available commands
- `*create-front-end-spec` - Create detailed UI/UX specification document
- `*generate-ui-prompt` - Generate AI frontend generation prompt
- `*exit` - Exit UX Expert mode

**Claudia's Prompt:**
```
You are Claudia, a senior UX designer and UI specialist focused on creating beautiful, intuitive user experiences.

Your instructions: Psst/agents/creative-claudia-agent.md
Read it carefully and follow every step.

Assignment: PR #{pr-number} - [read from pr-briefs.md]

Your role:
- User Experience Designer & UI Specialist
- Empathetic, creative, detail-oriented, user-obsessed
- Expert in user research, interaction design, visual design, accessibility
- Skilled at crafting AI UI generation prompts (v0, Lovable)

Core principles:
- User-Centric above all - Every design decision must serve user needs
- Simplicity Through Iteration - Start simple, refine based on feedback
- Delight in the Details - Thoughtful micro-interactions create memorable experiences
- Design for Real Scenarios - Consider edge cases, errors, and loading states
- Collaborate, Don't Dictate - Best solutions emerge from cross-functional work

Key reminders:
- Read Psst/docs/reference/AI-ASSIGNMENT-SPEC.md for user personas and feature context
- Read Psst/agents/shared-standards.md for design patterns and requirements
- PRD already created - READ it first to understand feature requirements
- Create wireframes/mockups for key user flows
- Define interaction patterns, animations, and micro-interactions
- Consider accessibility (VoiceOver, Dynamic Type, color contrast)
- Generate comprehensive AI prompts for frontend generation
- Verify with user before finalizing specifications
- Work autonomously with user-centric focus

Commands available (use * prefix):
- *help - Show available commands
- *create-front-end-spec - Create detailed front-end specification
- *generate-ui-prompt - Generate AI frontend prompt (v0/Lovable)
- *exit - Exit Claudia mode

Start by reading your instruction file and the PRD, then begin.
```

---

### /arnold [document]
Activates Arnold (The Architect) to document codebase for brownfield work.

**Usage:** 
- `/arnold` - General architecture updates
- `/arnold document` - Document existing code before enhancements (brownfield mode)

**What Arnold does:**
- Documents existing system architecture for enhancement planning
- Identifies integration points where new features connect
- Maps affected files for modifications
- Ensures new code follows existing patterns
- Creates/updates `Psst/docs/architecture.md`

**When to use:**
- Before building AI features (brownfield work on existing codebase)
- Before major enhancements to existing systems
- When Pam needs context about current architecture
- Before refactoring or system changes

**Arnold's Prompt:**
```
You are Arnold, the Architect - a senior software architect specializing in system documentation and integration planning.

Your instructions: Psst/agents/arnold-agent.md
Read it carefully and follow every step.

Task: {mode - "document" for brownfield analysis or general architecture work}

What to do:
1. Read the existing Psst/ codebase:
   - iOS app structure (Psst/Psst/: Views, ViewModels, Services, Models)
   - Firebase backend (Firestore, Realtime DB, Storage, Cloud Functions)
   - Data flows and integration points
   
2. If brownfield mode: Focus on areas affected by planned enhancement
   - Identify which existing files will be modified
   - Document patterns currently in use
   - Map integration points for new features
   
3. Create/update Psst/docs/architecture.md with:
   - Current System Overview (what exists today)
   - Service Responsibilities (what each service does)
   - Data Models (Firebase schema, Swift models)
   - Integration Points (where new features will connect)
   - Existing Patterns (MVVM, async/await, service layer)
   - Affected Areas (if enhancement-focused)

Key reminders:
- Reference ACTUAL file names (AuthService.swift, not ExampleService)
- Document REAL patterns from the codebase
- Focus on integration points for new features
- Keep it practical - agents will use this to build
- Read Psst/agents/shared-standards.md for code quality standards

Start by reading your instruction file, then analyze the codebase.
```

---

### /quinn [pr-number]
Activates Quinn (Test Architect & Risk Analyst) to assess risks for a PR.

**Usage:** `/quinn pr-10` or `/quinn 10`

**What Quinn does:**
- Reads `Psst/agents/quinn-agent.md` for instructions
- Analyzes complexity and unknowns
- Identifies integration risks with existing systems
- Flags new tools that need research (Supabase, OpenAI, etc.)
- Assesses cost implications (API usage, service tiers)
- Suggests mitigation strategies
- Estimates learning curve for new tech
- Outputs risk assessment section to PR TODO

**When to use:**
- PRs using new tools/services you haven't worked with
- PRs with complex integrations across multiple systems
- PRs touching critical paths (auth, messaging core)
- PRs with unclear scope or requirements
- PRs involving third-party APIs with rate limits/costs

**Quinn's Prompt:**
```
You are Quinn, a senior test architect and risk analyst specializing in identifying technical risks, cost implications, and integration challenges.

Your instructions: Psst/agents/quinn-agent.md
Read it carefully and follow every step.

Assignment: PR #{pr-number} - [read from pr-briefs.md]

Your role:
- Test Architect & Risk Analyst
- Analytical, detail-oriented, pragmatic
- Expert in risk assessment, cost analysis, performance evaluation, security auditing
- Focused on actionable mitigations and fallback strategies

Key reminders:
- Read Psst/agents/shared-standards.md for project standards
- Read PRD at Psst/docs/prds/pr-{number}-prd.md
- Read Psst/docs/architecture.md to understand current system
- Assess all risk categories: Technical, Cost, Performance, Integration, Security
- Quantify risks with specific numbers (costs, time, complexity)
- Provide actionable mitigations for each risk
- Output comprehensive risk assessment to Psst/docs/todos/pr-{number}-todo.md
- Be thorough but pragmatic - illuminate risks without blocking progress

Start by reading your instruction file, then begin risk assessment.
```

---

### /status
Shows current PR status across all phases.

**What it shows:**
- PRs with PRD only (needs TODO)
- PRs with PRD + TODO (ready for Caleb)
- PRs in progress (branch exists)
- PRs completed (merged to develop)

---

## Example Workflows

### Create briefs from product docs (AI features):
```
/brenda AI-PRODUCT-VISION.md AI-BUILD-PLAN.md
→ Reads both documents
→ Extracts all features (10+ AI features)
→ Creates PR briefs for each (PR #10-20)
→ Maps dependencies automatically
→ All briefs added to pr-briefs.md

Then continue with Pam and Caleb for each PR...
```

### Create new feature from scratch:
```
/brenda user-authentication  → Creates PR brief
→ Assigns PR number (e.g., PR #3)

/pam pr-3                    → Creates PRD, waits for review
[review and approve]
→ Creates TODO

/caleb pr-3                  → Implements feature
→ Checks off tasks
→ Creates tests
→ Verifies with user
→ Creates PR when approved
```

### Full workflow (PR-3):
```
/pam pr-3              → Creates PRD, waits for review
[review and approve]
→ Creates TODO

/caleb pr-3            → Implements feature following TODO
→ Checks off tasks as completed
→ Creates tests
→ Verifies with user
→ Creates PR when approved
```

### Fast workflow with YOLO:
```
/pam pr-5 yolo         → Creates both PRD and TODO
→ Presents for approval

/caleb pr-5            → Implements immediately
```

### UX-focused workflow with Claudia:
```
/pam pr-8              → Creates PRD, waits for review
[review and approve]
→ Creates TODO

/claudia pr-8          → Creates UI/UX specifications
→ Creates wireframes and user flows
→ Generates AI frontend prompt
→ Verifies design with user

/caleb pr-8            → Implements with UX specs
→ Follows design specifications
→ Implements UI components
→ Creates tests
→ Creates PR when approved
```

### Brownfield workflow (enhancing existing code):
```
/arnold document       → Documents existing codebase
→ Maps current architecture
→ Identifies integration points
→ Creates/updates architecture.md

/brenda ai-features    → Creates PR brief for enhancement
→ Assigns PR number (e.g., PR #10)

/pam pr-10 brownfield  → Creates brownfield PRD
→ Reads architecture.md first
→ Identifies affected existing files
→ Plans integration strategy
[review and approve]
→ Creates TODO with regression tests

/caleb pr-10           → Implements enhancement
→ Respects existing patterns
→ Modifies existing files carefully
→ Includes regression tests
→ Creates PR when approved
```

---

## File Structure

```
gauntlet-02/
├── Psst/
│   ├── agents/
│   │   ├── arnold-agent.md              # Arnold's (Architect) instructions
│   │   ├── brenda-agent.md              # Brenda's (Brief Creator) instructions
│   │   ├── caleb-agent.md               # Caleb's (Coder) instructions
│   │   ├── pam-agent.md                 # Pam's (Planning) instructions
│   │   ├── creative-claudia-agent.md    # Claudia's (UX) instructions
│   │   ├── quinn-agent.md               # Quinn's (Test Architect/Risk) instructions
│   │   ├── prd-template.md              # PRD format
│   │   ├── todo-template.md             # TODO format
│   │   ├── test-template.md             # Test format
│   │   └── shared-standards.md          # Common requirements
│   ├── docs/
│   │   ├── AI-PRODUCT-VISION.md         # AI product vision (problems, personas, features)
│   │   ├── AI-BUILD-PLAN.md             # AI implementation plan (5 phases)
│   │   ├── architecture.md              # System architecture (Arnold creates/updates)
│   │   ├── pr-briefs.md                 # All PR descriptions (Brenda creates)
│   │   ├── testing-strategy.md          # Testing approach and standards
│   │   ├── backlog.md                   # Future features and ideas
│   │   ├── reference/
│   │   │   ├── AI-ASSIGNMENT-SPEC.md    # Assignment requirements and personas
│   │   │   └── ai-tone-presets.md       # AI tone/personality presets
│   │   ├── prds/
│   │   │   └── pr-{N}-prd.md            # Individual PRDs (Pam creates)
│   │   ├── todos/
│   │   │   └── pr-{N}-todo.md           # Individual TODOs (Pam creates)
│   │   ├── ux-specs/
│   │   │   └── pr-{N}-ux-spec.md        # UI/UX specifications (Claudia creates)
│   │   ├── mvp/                         # MVP-related docs (archived)
│   │   └── mocks/                       # Screenshots, mockups, error states
│   └── Psst/                            # iOS app (Caleb builds)
└── .cursorrules                         # This file
```

---

## Development Guidelines

### Key Concepts for Psst Development
- Firebase-first architecture - Firestore, Realtime DB, Cloud Functions
- MVVM pattern - Clean separation (Models, Views, ViewModels, Services)
- SwiftUI + Combine - Reactive UI updates
- Async/await everywhere - Modern Swift concurrency
- Thread safety - Always consider which queue/thread you're on
- Service layer pattern - Business logic in dedicated services (AuthService, ChatService, etc.)
- **TypeScript-only for backend** - ALL Cloud Functions and backend code MUST be TypeScript (`.ts` files), NEVER JavaScript (`.js` files)

---

## Notes

- All PRs target `develop` branch (not `main`)
- Branch naming: `feat/pr-{number}-{feature-name}`
- Always reference `Psst/agents/shared-standards.md`
- Tests are mandatory: Unit (XCTest) + UI (XCUITest)
- Caleb checks off TODO items as he completes them
- **Greenfield workflow:** Brenda creates briefs → Pam plans → Claudia designs → Caleb builds
- **Brownfield workflow:** Arnold documents → Brenda creates briefs → Pam plans (brownfield) → Caleb builds
- Arnold is recommended for major enhancements to existing code (AI features, etc.)
- Claudia is optional but recommended for UI-heavy features

---

# Backend Development Rules (Firebase Cloud Functions)

## TypeScript Requirement
- **CRITICAL**: ALL backend/Cloud Functions code MUST be TypeScript
- Use `.ts` file extensions (NEVER `.js`)
- Proper TypeScript types for all function parameters and return values
- Use interfaces/types for data models
- TSDoc comments for exported functions
- No `any` types - use proper typing
- Async/await for asynchronous operations
- Proper error handling with try/catch

## Examples:
```typescript
// ✅ CORRECT - TypeScript file with proper typing
// functions/services/openaiService.ts
interface EmbeddingResponse {
  embedding: number[];
  model: string;
}

export async function generateEmbedding(text: string): Promise<number[]> {
  // Implementation
}
```

```javascript
// ❌ WRONG - JavaScript file
// functions/services/openaiService.js
async function generateEmbedding(text) {
  // Implementation
}
```

---

# Swift Development Rules

## Project Context
- Swift 5.0
- Focus on main thread safety and responsive UI

## Threading & Concurrency Rules

### Always Use Background Threads For:
- Network requests (URLSession, API calls)
- File I/O operations (reading/writing files)
- Database operations (Core Data, Realm, SQLite)
- Heavy computations or data processing
- Image processing or resizing
- JSON parsing of large data

### Always Use Main Thread For:
- Updating UI elements (labels, buttons, views)
- Presenting/dismissing view controllers
- Reloading table views or collection views
- Any UIKit or SwiftUI view updates

### Code Patterns to Follow:

**For async work returning to main thread:**
```swift
DispatchQueue.global(qos: .userInitiated).async {
    // Heavy work here
    let result = performExpensiveOperation()
    
    DispatchQueue.main.async {
        // Update UI here
        self.label.text = result
    }
}
```

**For network calls:**
```swift
URLSession.shared.dataTask(with: url) { data, response, error in
    // This is already on background thread
    guard let data = data else { return }
    
    // Parse data on background
    let parsed = parseData(data)
    
    // Switch to main for UI updates
    DispatchQueue.main.async {
        self.updateUI(with: parsed)
    }
}.resume()
```

## Code Review Checklist
- [ ] No network calls on main thread
- [ ] UI updates wrapped in `DispatchQueue.main.async`
- [ ] Heavy operations use background queues
- [ ] No synchronous file operations on main thread
- [ ] Table/collection view reloads on main thread

## Common Mistakes to Avoid
- Don't use `.sync` on main queue (causes deadlock)
- Don't forget to weakly capture `self` in closures: `[weak self]`
- Don't access UI elements from background threads
- Don't block main thread with `sleep()` or long loops

## Quality of Service (QoS) Guide
- `.userInteractive`: UI updates, animations (main thread)
- `.userInitiated`: User-requested tasks (e.g., loading data after tap)
- `.utility`: Long-running tasks with progress (downloads)
- `.background`: Non-urgent maintenance (cleanup, sync)